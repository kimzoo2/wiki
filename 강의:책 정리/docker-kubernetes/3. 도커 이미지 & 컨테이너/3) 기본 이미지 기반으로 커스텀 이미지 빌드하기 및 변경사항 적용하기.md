
>dockerhub에서 제공하는 코드를 사용해서 내가 작성한 코드를 어떻게 작동 시킬 수 있을까?

공식 베이스 이미지를 가져온 다음, 그 위에 코드를 추가해서 그 이미지로 코드를 실행한다.
공유하지 않는 한 도커 허브에 공개되진 않는다.

Dockerfile을 작성하여 커스텀 이미지를 생성할 수 있다.

```dockerfile
# 다른 베이스 이미지로부터 이미 구축할 수 있는 명령어

FROM node
# FROM - 노드 이미지를 가져와

WORKDIR /app
# WORKDIR : 도커가 작업할 경로를 지정한다
# 도커가 작업해야 할 경로를 지정해줌 도커에게 모든 실행이 해당 폴더에서 진행됨

COPY . /app
# COPY : 이미지에 로컬의 파일을 복사해라
# 절대 경로 방식 : 로컬에 있는 파일을 이미지에 넣어
# 첫번째 . : 컨테이너 외부. dot이면 Dockerfile이랑 같은 경로다. 모든 파일을 복사해라.
# 두번째 . : 컨테이너 내부 경로. 도커는 내부에 자체 내부 파일 시스템을 가짐.

# -> Dockerfile과 같은 경로에 있는 모든 파일, 폴더를 도커 내부 /app 경로에 복사해라

# COPY . ./
# 상대경로 방식 : 카피할 디렉토리를 현재 WORKDIR에서 실행해라.
  
RUN npm install
# RUN : 명령을 실행해라. 빌드할 때마다 실행된다.
# 명령을 실행해라. 디폴트 작업 시스템에서 실행되며 컨테이너의 루트 폴더에서 실행됨.

EXPOSE 80
# EXPOSE : 컨테이너 안의 프로세스가 특정 포트로 실행됨을 알려주는 메타데이터 (실제 노출은 아님)
# 로컬에 특정 포트를 오픈해주고 싶을 때 사용하는 명령어
# 컨테이너 내부에서만 특정 포트를 열어두고 수신을 대기 중임

호스트 머신
├── 8080포트 (호스트의 포트)
└── Docker 컨테이너
  └── 80포트 (컨테이너 내부의 포트)
  
# docker run으로 로컬 포트와 연결하지 않으면 컨테이너가 노출한 포트는 무의미하다.

CMD ["node", "server.js"]
# CMD : 컨테이너를 실행하는 명령어, RUN과 달리 이미지 생성 시에는 실행되지 않는다.
# 모든 작업이 완료되면 이미지를 기반으로 컨테이너를 시작해라
# 이미지를 생성할 때는 실행되지 않는다는 특징이 있음
# 컨테이너 내부의 node에게 server.js를 실행하도록 명령 내리는 방식
```


> docker build [Docker 파일 경로]
- 컨테이너에게 Dockerfile을 기반으로 이미지를 만들라고 명령한다.


#### 변경사항 적용하기
이미지는 변경되어도 반영되지 않는다. 스냅샷이 유지되기 때문이다.
변경사항이 발생했을 때는 **이미지를 새로 빌드**해야만 한다.

추후 변경사항을 적용하는 아름다운 방법을 알려준다고 함