# AOP
## AOP(Aspect of Programming)란?
- 관점 지향 프로그래밍이라는 뜻으로, 핵심 기능과 인프라 기능(=부가 기능)을 분리하여 개발자가 핵심 비즈니스 로직에 집중할 수 있게 해주는 모듈화 방식이다.
- 프록시를 활용한 **데코레이터 패턴으로 구현**되어 있으며 대표적으로는 `@Transactional`이 존재한다.

### `@Transactional`의 동작원리
- @Transactional 키워드가 붙은 클래스나 메소드를 호출할 때, 빈으로 등록되어 있는 프록시 객체를 호출한다.
- 프록시는 내부적으로 커넥션을 가져와서 트랜잭션을 시작한다.
- 타겟 객체를 호출한다.
- 트랜잭션을 종료하고 타겟 객체의 응답을 반환한다.

### 주의점
- private 메소드는 프록시 적용이 불가하다.
	- 프록시 객체를 활용했기 때문이다. 프록시 객체는 타겟 클래스를 기반으로 구현하지만 private 메소드는 상속이 불가하기 때문이다.
- 타겟 메소드 -> 타겟 메소드 호출은 각 트랜잭션을 적용하지 않을 수 있다.

### 전략 패턴과 템플릿 메서드 패턴
>AOP는 결국, 변하는 것(비즈니스 로직)과 변하지 않는 것(인프라 로직)을 분리하는 작업이다.
  이러한 상황에 OOP를 활용하여 문제를 해결하기 좋은 패턴이 **템플릿 메서드 패턴**과 **전략 패턴**이다.

#### 템플릿 메서드 패턴
 상속을 기반으로 한 디자인 패턴이다. 템플릿이라는 변하지 않는 코드와 훅 메서드라는 변하는 코드를 구현해서 템플릿 메서드가 1) **실행 흐름을 제어**하고 2) **특정 알고리즘을 동적으로 변경**할 수 있다는 특징이 있다.
 하지만 상속이기 때문에 템플릿 메서드가 서브 클래스도 상속 받는다는 특징이 있다.

#### 전략 패턴
조합을 기반으로 한 디자인 패턴이다. 컨텍스트란 변하지 않는 클래스와 strategy라는 변하는 코드를 구현해 알고리즘을 동적으로 변경할 수 있다.
인터페이스를 활용하기 때문에 불필요한 상속이 발생하지 않는다는 특정이 있다.

### 하지만 적합하지 않다.
템플릿 메서드 패턴과 전략 패턴을 활용해서 부가 기능을 추가하면 결국 비즈니스 로직을 구현하는 클래스에 **DI를 해야만 한다**. 기능은 분리했으나 클래스마다 부가 기능 클래스가 존재하고 변경에 유연하게 대응할 수 없다.

## 프록시 패턴과 데코레이터 패턴
> 그렇다면, SRP를 지킬 수 있는 방법은 없을까? 바로 프록시를 활용한 방식이다.

프록시란 대리자라는 뜻으로 내부에 타겟이 되는 원래 객체를 필드에 저장한다. 그로 인해 클라이언트가 타겟 객체를 호출할 때 요청을 가로채어 부가로직을 추가하고 타겟 객체를 호출하여 SRP를 지킬 수 있다.
프록시 객체는 두가지 기능을 한다.
- **접근 제어**
	- 캐싱
	- lazy loading
	- 권한 제어
- **부가 기능 추가**

### 프록시 패턴
프록시 패턴은 **대리자를 두어 접근 제어를 하는 디자인 패턴**이다. client가 target 객체를 호출할 때 요청을 가로채어 캐싱을 하거나 권한에 따른 제어를 추가할 수 있다.

### 데코레이터 패턴
데코레이터 패턴은 프록시(=대리자)를 두어 **부가기능을 추가하는 디자인 패**턴이다. client가 target 객체를 호출할 때 요청을 가로채어 부가기능을 추가하고 target을 호출한다.

### 프록시와 데코레이터 패턴 그 차이는?
**의도(intent)** 다. 프록시는 두가지 기능을 한다고 했다. 접근 제어와 부가 기능 추가이다. GOF에 따르면 여기서 접근 제어라는 의도를 가지면 프록시 패턴이라고 하고 부가 기능을 추가하는 의도를 가지면 데코레이터 패턴이라 할 수 있다.

### 하지만 아쉽다.
타겟 객체와 타입이 동일한 **프록시 클래스를 매번 생성**해야 한다. 인터페이스든 구체 클래스든 상관 없이 말이다. 이는 결과적으로 **중복을 야기**한다.

## 동적 프록시 기술
> 그렇다면 **동적으로 프록시를 한 번만 생성하는 방법은 없을까?**
> 바로 리플렉션 기술을 활용한 jdk 동적 프록시 기술과 cglib 방식이 존재한다.

### jdk dynamic proxy
- **리플렉션**과 **인터페이스**를 기반으로 동적으로 프록시를 생성할 수 있는 방식이다.
- `InvocationHandler`를 통해 동적으로 프록시를 구현한다.

![[invocationHandler.jpeg]]

원래는 각 타겟 클래스마다 부가 기능을 추가한 프록시 객체를 개발자가 직접 구현해줘야만 했다. 부가 기능 로직이 중복되어 유지보수하기 어려운 상태다.

OrderControllerV2 -> OrderControllerConcreteProxy 구현
OrderRepositoryV2 -> OrderRepositoryConcreteProxy 구현

하지만 `InvocationHandler`에 부가 기능을 구현하면 프록시 객체에 부가기능을 구현하지 않고도 부가기능을 추가할 수 있게 된다. 모든 요청이 handler로 전달되기 때문에 중복을 제거할 수 있다.


> **리플렉션이란?**
> - 리플렉션이란 **메타데이터에 접근**하여 클래스를 조작할 수 있는 라이브러리다. 생성자, 필드, 메소드, 어노테이션 등에 모두 접근이 가능하다.
>   
>   **장점**
>   - 클래스 메타데이터에 접근할 수 있기 때문에 **유연한 조작**이 가능하다.
>   **단점**
>   - **private 필드나 메소드에 접근**할 수 있기 때문에 캡슐화가 깨진다.
>   - **런타임에 동적으로 변경**되기 때문에 컴파일 타임에 문제를 해결하기 어렵다.


### cglib
**바이트 코드를 조작**해서 **구체 클래스를 상속**하여 프록시 객체를 생성하는 기술이다. 상속을 기반으로 하기 때문에 제약이 많다.
- final한 객체는 프록시 객체로 생성할 수 없다.
- private 메소드에는 접근할 수 없다.
- 부모 클래스의 생성자를 확인해야 한다. `super(null);` 로 구현해야 함

`MethodInterceptor`를 사용하며 부가기능을 구현한다. Enhancer 클래스를 통해 프록시 객체를 생성할 수 있다.
```java
Enhancer enhancer = new Enhancer();  
enhancer.setSuperclass(ConcreteService.class);  
enhancer.setCallback(new TimeMethodInterceptor(target));  
ConcreteService proxy = (ConcreteService) enhancer.create();
```


### 그래도 아쉽다.
인터페이스일 때 InvocationHandler를 구현해서 프록시를 생성하고 구체 클래스일 때 MethodInterceptor를 상속받아 프록시를 자동으로 생성해줄 수는 없을까?
필터링 기능을 추가할 수는 없을까? 예를 들어, 로그를 추적하고 싶은 메소드에만 적용하는 방법은 없을까?

## 나야, 프록시 팩토리
프록시 팩토리를 사용하면 인터페이스일 때는 InvocationHandler가 구현되고 구체 클래스일 때는 MethodInterceptor가 상속되어 프록시 객체가 생성된다. (인터페이스도 MethodInterceptor가 가능하지 않나요? 된다, 이건 후술한다.)
- `proxyTargetClass=true` 를 설정하면 무조건 CGlib에 의해 프록시를 생성한다.

#### 흐름
![[스크린샷 2025-02-13 오후 1.31.04.png]]
client -> 프록시(프록시 팩토리에 의해 생성됨) -> handler 실행 -> 어드바이스 실행 -> target 실행

또한 프록시 팩토리부터는 `Advice`, `Pointcut`, `Advisor`라는 개념이 등장한다. AOP 관점이 아닌 프록시 관점에서 세가지를 설명하자면,

### 어드바이스, 포인트컷, 어드바이저
#### Advice
- 타겟 객체에 추가할 부가 기능이다.

#### Pointcut
- 부가 기능이 적용될 수 있는 위치이다. 즉, 필터링해주는 로직이다. 어떤 포인트(Point)에 기능을 적용하지 않을지 잘라서(cut) 구분한다.

#### Advisor
- 하나의 Advice + 하나의 Pointcut을 가지고 있는 것이다.

즉, 어디에 무슨 기능이 적용될지 알고 있는 것이 `Advisor`이다.

##### 스프링이 제공하는 포인트컷
`Pointcut` 인터페이스를 구현해서 포인트컷을 적용할 수 있다. 하지만, 우리는 스프링이 제공하는 포인트컷을 사용해보자.

- `NameMatchMethodPointcut` : 메서드 이름을 기반으로 지정한다. 내부에서 `PatternMatchUtils` 을 사용하여 메서드 패턴을 적용한다.
- `AspectJExpressionPointcut` : aspectJ 표현식을 이용해서 지정한다.


### 여러 어드바이저 적용하기
그렇다면 여러 부가기능을 적용하고 싶으면 어떻게 하면 될까? 예를 들어, Service 클래스의 find() 메소드에 1)로그도 추적하고 2)수행 시간도 확인하고 싶다.

우선 프록시 클래스를 여러개 만들면 되지 않을까?

#### 여러개의 프록시 클래스 적용
![[스크린샷 2025-02-13 오후 1.39.49.png]]
필터링 하듯이 프록시1을 생성하고 프록시2를 생성해서 각각 호출하게 만든다. 빈을 등록할 때 proxy2 안에 proxy1로 proxy1 안에 target을 주입해주면 된다.
좋은 방법이다. 하지만 **부가 기능을 추가할 때마다 프록시 클래스를 생성해야 한다**는 단점이 있다.

#### 하나의 프록시, 여러개의 어드바이저
스프링은 여러개의 프록시를 생성하지 않고 하나의 프록시 클래스만 생성한다. 그리고 여러개의 어드바이저를 호출한다.

![[하나의_프록시_여러개의_어드바이저.png]]

여러 프록시를 생성할 때보다 **기능은 같고, 성능은 더 좋다**.


### 그래도 부족하다.
프록시 팩토리를 이용하고 어드바이스, 포인트컷, 어드바이저 개념을 통해 어디에 무슨 부가 기능을 적용할지 명확해졌다. 이제는 interface를 구현하지 않아도 구현체를 상속 받아 구현하지 않아도 프록시 클래스가 동적으로 생성된다.

하지만, 아래의 문제가 남아있다.

- **어드바이저를 등록하는 설정 파일이 너무 길다.** 매번 클래스를 생성하진 않지만 부가기능을 적용하는 클래스마다 프록시 팩토리를 통해 설정하려고 한다면 트랜잭션을 지금처럼 적용하기 어려울 것 같다.
- **컴포넌트 스캔에는 프록시를 추가하기 어렵다.** 우리는 여태껏 개발한 클래스를 설정 파일을 통해 빈으로 등록했다. 컴포넌트 스캔에 의해 자동으로 빈에 등록하는 대상은 어떻게 핸들링할 수 있을까?


## Bean PostProcessor(빈 후처리기)
- 생성한 빈을 저장소에 등록하기 전에 조작하고 싶다면 **빈 후처리기를 사용**하면 된다.
- 빈 후처리기는 막강하다. 빈을 조작할 수도 아예 다른 객체로 변경하는 것도 가능하다. 즉, **타겟 클래스를 프록시 클래스로 변경하는 것도 가능**하다.

`BeanPostProcessor` 인터페이스를 구현하여 빈 후처리기를 등록하자. 구현한 빈 후처리기에서 프록시를 생성하고 설정 파일에서 어드바이저를 생성하여 빈 후처리기로 넘기자. 그러면 설정 파일에서 매번 프록시를 생성하는 설정이 제거된다.

간단한 수도 코드를 통해 이해해보자.

``` java

@설정파일
class 스프링 설정 파일 {

  @빈등록
  빈후처리기_등록_메서드 {
     빈후처리기 생성(어드바이저_생성_메서드)
  }

  어드바이저_생성_메서드 {
    어드바이저 생성
    생성한 어드바이저 반환
  }

}

class 커스텀 빈 후처리기 {

	빈후처리기_시작_메서드(등록한 빈) {
	
	  // 프록시 등록 대상 여부 체크
	  if(!프록시 등록할 패키지인가?) {
	    등록한 빈 반환 
	  }
	
	  // 프록시 객체 생성
	  프록시 팩토리에 어드바이저 등록
	  프록시 생성
	
	  생성한 프록시 객체 반환
	}

}

```

우리가 만든 커스텀 빈 후처리기에 의해, 프록시가 적용될 패키지만 프록시가 생성된다. 그리고 어드바이저에 의해 프록시가 적용될 메서드에만 부가기능이 적용된다. 현재는 빈 후처리기에 의해서 프록시 생성할 대상을 지정했다.
프록시 등록 대상 여부를 왜 체크해야할까? 빈 후처리기는 모든 빈에 적용되기 때문이다. 심지어 스프링이 만든 빈도 빈 후처리기에 의해 처리될 수 있다. 우리는 우리가 만든 객체에만 부가 기능을 적용하고 싶기 때문에 적용 대상을 필터링한다.
참고로 프록시를 생성할 대상을 지정하는 건 포인트컷으로도 가능하다. 스프링 AOP에서는 실제로 그렇게 하고 있다. (수도 코드는 그저 예시다.)

그렇다면, **포인트컷 사용 대상은 두가지다.**

- 프록시 생성할 대상 지정 (프록시 생성 여부)
- 어드바이스를 지정할 대상 지정 (프록시 내에서 작용)

빈 후처리기 덕분에 문제는 해결되었다. 앞으로 우리는 빈 후처리기를 구현하면 될까? 아니다. 스프링은 프록시를 생성해주는 빈 후처리기를 이미 지원한다.

### 스프링이 지원하는 빈 후처리기 `AutoProxyCreator`
스프링은 정말 감사하게도 프록시를 생성해주는 빈 후처리기를 지원한다. 이 말의 뜻은 우리가 어드바이저를 등록하기 위해 빈 후처리기를 생성할 일도, 빈 후처리기를 등록할 일도 없다는 뜻이다. 스프링은 `AnnotationAwareAspectJAutoProxyCreator`를 자동으로 등록한다.

##### 스프링의 자동 프록시 생성기
- 하나의 프록시를 자동으로 생성해준다. (AspectJ와 관련된 @Aspect도 지원해준다.)
- 빈으로 등록된 어드바이저를 자동으로 찾아서 프록시가 필요한 곳에 프록시를 적용해준다.

#### 흐름
![[자동프록시_생성기_흐름.png]]
스프링에 의해 빈이 전달되면 빈 후처리기인 자동 프록시 생성기가 advisor에 의해 프록시를 생성할 수 있는지 확인한다. 적용이 가능한 대상이면 프록시를 생성해서 타겟 빈 대신 프록시를 등록한다.


#### 보다 세밀한 포인트컷
말했다시피 포인트컷은 두 가지에 사용된다. 프록시 생성할 대상을 필터링하고 어드바이스가 적용될 위치를 필터링한다. 세밀한 포인트컷을 스프링은 지원한다. 바로 `AspectJExpressionPointcut`이다. Aspectj 표현식에 의해 포인트컷을 지정할 수 있기 때문에 패키지, 클래스, 메소드를 특정해서 지정할 수 있다.
그냥 우리가 개발한 프로그램에 프록시를 모두 생성하면 편하지 않을까? 안 된다. 프록시를 생성하고 관리하는 것은 비용 낭비다. 그렇기 때문에 부가 기능을 적용할 곳만 프록시를 생성해야만 한다.