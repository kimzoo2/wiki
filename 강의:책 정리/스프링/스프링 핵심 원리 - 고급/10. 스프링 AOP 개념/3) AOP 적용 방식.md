지금까지는 프록시를 통해서 AOP를 구현하는 방식이었다.
그렇다면 AOP를 사용할 때 부가 기능 로직은 어떤 방식으로 실제 로직에 추가될까?

일반적으로 **세가지 방법**이 있다.
- 컴파일 시점
- 클래스 로딩 시점
- 런타임 시점 (=프록시 방식)

### 컴파일 시점
**클래스 파일`(.class)`이 생성**될 때 **aspectj**에 의해서 코드가 삽입된다. 물론 aspectJ가 사용하는 **특별한 컴파일러를 사용해야 한다**. 해당 컴파일러를 사용하면 aspect 관련 호출 코드가 들어있다.
즉, aspectJ 컴파일러를 사용하면 컴파일 시점에 적용 대상인지 확인하고 부가 기능 로직을 삽입(=위빙)한다.

**단점**
- **특별한 컴파일러가 필요해서 복잡**하다.

### 클래스 로딩 시점
.class 파일을 jvm 내부 클래스 로더에 보관한다. 이때 중간에 `.class` 파일을 조작하고 jvm에 올린다. `java instrumentation`을 검색하면 나온다. 많은 모니터링 툴들이 이 방식을 사용한다.

**단점**
- 특별한 **옵션을 통해 조작기를 지정**해야 한다. 번거롭다.

### 런타임 시점
여기서 런타임이란 메인 메서드가 실행된 다음을 의미한다. **프록시, DI, 빈 포스트 프로세서** 같은 개념들을 동원해서 부가 기능을 적용할 수 있다. 이것이 바로 스프링이 지원하는 **프록시 방식의 AOP**이다.

**단점**
프록시를 사용하기 때문에 일부 기능에 제약이 있다. final이나 생성자에 aop 호출이 어렵다. 하지만 특별한 컴파일러나 클래스 로더 조작기를 설정하지 않아도 된다. 스프링만 있으면 aop 적용할 수 있다.

**원래 AOP는 조인 포인트(적용 가능 지점)가 아주 많다.** aspectJ는 실제 코드를 조작하기 때문에 해당 기능을 모든 지점에 다 적용할 수 있기 때문이다.
**하지만 스프링 AOP는 메서드 실행 시점에만 AOP를 적용할 수 있다.** 생성자나 **static 메서드, 필드 값 접근에는 프록시 개념이 적용될 수 없다**. (타겟 객체를 빈으로 등록해야 한다는 한계도 존재)


> **참고**
> 스프링은 AspectJ의 문법을 차용한다. AspectJ를 직접 사용하지 않는다.


### 그렇다면 AspectJ를 사용하는게 낫지 않나?
- 더 다양한 기능이 많지만 AspectJ를 사용하려면 컴파일러, 전용 문법, 자바 실행 옵션 등을 지정해야 한다. 하지만 스프링 **AOP는 별도 설정 필요 없이 AOP를 사용할 수 있다**는 특징이 있다.


## AOP 용어 정리
#### 조인 포인트
- **어드바이스가 적용될 수 있는 위치**. 메소드 실행, 생성자 호출, 프로그램 실행 중 지점 등
- 조인 포인트는 추상적인 개념으로 AOP를 적용할 수 있는 모든 지점을 의미한다.
- **스프링 AOP는 언제나 메소드 실행 지점으로 제한**된다.

#### 포인트컷
- **여러 조인 포인트 중에서 어드바이스가 적용될 수 있는 위치를 선별**한다.
- AspectJ 표현식으로 지정한다. (`@Around`)
#### 타겟 (=실제 객체)
- 어드바이스를 받는 객체, 포인트컷으로 결정

### 어드바이스
- 부가 기능
- Around(주변), Before(전), After(후)와 같이 다양하다.

### 애스펙트
- 어드바이스 + 포인트컷을 모듈화한 것이다.
- **@Aspect**를 생각하자.
- **여러 어드바이스와 포인트컷이 존재**한다.

### 어드바이저
- **하나의 어드바이스 + 하나의 포인트컷**
- 스프링 AOP에서만 사용하는 언어

### 위빙
- 포인트컷으로 지정한 타켓의 조인 포인트에 어드바이스를 적용하는 것을 의미한다.

### AOP 프록시
- 스프링은 jdk dynamic proxy, cglib 프록시가 존재한다.

## 포인트컷 적용
```java
@Aspect  
public class AspectV1 {  
  
    @Around("execution(* hello.aop.order..*(..))") // 포인트컷  
    public Object doLog(ProceedingJoinPoint joinPoint) throws Throwable { // 어드바이스  
       log.info("[log] {}", joinPoint.getSignature()); // join point 시그니처  
       return joinPoint.proceed(); // 타겟 실행  
    }  
}
```
- @Aspect와 @Around를 활용하여 포인트컷을 구현해보자.
- @Around는 `ProceedingJoinPoint` 로 타겟 클래스를 실행하거나 시그니처 등을 가져올 수 있다.

