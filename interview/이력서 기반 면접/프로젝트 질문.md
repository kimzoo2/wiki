
좋은 단어
- **데이터 신뢰성** : 유실 시키지 않는 경우
	- 이벤트 발행했을 때 데이터가 유실되면 안 되기 때문에 트랜잭셔널 아웃박스 패턴 사용. 로컬 트랜잭션을 사용해서 데이터베이스에 이벤트를 저장하고 발행하여 정합성을 보장함

**트랜잭셔널 아웃박스 패턴**
- 언제, 누가, 어떤 이벤트를 해서, 어떤 변화 있는지, 이벤트 발행 여부 확인 (됐는가?랑 언제?)
- 미발행 이벤트를 배치 등으로 처리하기

### SSE 왜 썼죠
- TCP 연결 유지
- 클라이언트가 요청 보내지 않아도 서버에서 지속적으로 응답 전달 가능
- 서버에서 응답 보낼 때마다 연결 유지된 경우 헤더 생략 가능
- 콜론으로 보내는 메세지는 클라이언트한테 무시됨 (heartbeat 구현 가능)

### named-lock의 문제점
동시성을 제어하기 위해 **비즈니스 로직과 락을 거는 트랜잭션을 분리**해야 하는데 이때, 커넥션이 하나 더 소비됩니다. 이때문에 **커넥션**을 사용하려는 다른 기능에서 응답 지연이 발생할 수도 있다는 단점이 있습니다.
개발자가 **명시적으로 락 해제를** 해야 하기 때문에 **휴먼 에러**도 발생할 수 있다.


### 알림 이벤트가 발생할 때만 커넥션을 맺으면 되지 않나요?
**타이밍 특정**이 어려울 것 같습니다. 저희 프로젝트에서 스쿼드에 팀원을 초대하면 **초대 당한 팀원에게 알림이 전달**됩니다. 그러면 초대된 팀원이 sse 연결이 되어야하기 때문에 알람을 전달할 수 있게 됩니다. 그렇기 때문에 로그인할 유저가 커넥션을 맺어 알림을 응답받는 것이 더 적합하다고 판단했습니다.

### exceptionHandler 동작 원리에 대해서 설명해주세요.
ExceptionHandler는 **@Controller** , **@RestController** 가 적용된 Bean 에서 **발생하는 예외를 잡아서 처리해주는 기능**입니다.
- 에러가 발생하면 기본적으로 **WAS에 에러가 전파**됩니다.
하지만 exceptionHandler와 같이 예외를 핸들링할 수 있는 클래스가 있다면 예외가 발생
-> **HandlerExceptionResolver**가 @ExceptionHandler로 다룰 수 있는 예외 확인
-> 있으면 에러 핸들링 후 WAS로 정상 응답


### exceptionHandler로 타입미스매치 등의 스프링 에러는 어떻게 처리했나요?

스프링은 스프링의 예외를 미리 처리해둔 ResponseEntityExceptionHandler 를 가지고 있습니다. exceptionhandler와 controllerAdvice를 처리하는 클래스가 상속 받아 오버라이딩하면 사용자가 원하는 대로 에러를 처리할 수 있습니다.

- MethodArgumentTypeMismatchException 등을 처리해줌

출처: [https://mangkyu.tistory.com/205](https://mangkyu.tistory.com/205) [MangKyu's Diary:티스토리]


### 어떻게 EventListener로 구현했나요?
**처음엔 DI**를 통해 구현하려 했으나, 도메인 간의 결합도가 높아지고 알림 도메인이 실패하면 **메인 도메인도 롤백이 된다는 문제점**이 있었습니다. **결합을 느슨하게** 만들기 위해 도메인 로직이 수행 되면 `EventPublisher`를 통해 이벤트를 발생하였습니다. `@TransactionalEventListner`를 선언한 클래스에서 이벤트를 전달 받아서 알림 서비스 로직을 수행했습니다. 스프링 이벤트는 기본적으로 **동기식**이기 때문에 **비동기식으로 처리**하기 위해 `@Async` 어노테이션으로 처리했습니다.

> `ApplicationEventMulticaster`를 통해 이벤트를 비동기적으로 처리할 수 있다.
> 하지만, 글로벌하게 적용되기 때문에 특정 이벤트만 비동기로 관리하고 싶다면 `@Async`를 활용해서 처리할 수 있다.


### 주의할 점 
- @TransactionalEventListner의 **AFTER_COMMIT 시**, 공식 문서에도 나와있다시피 **트랜잭션이 커밋된 다음 변경사항에 대해 적용되지 않습니다**. 그래서 새로운 트랜잭션을 열어주어야 합니다. 예를 들어 `propagation` 설정을 통해 새로운 트랜잭션을 열 수 있습니다.
- **메세지 발행이 실패**할 수 있다. 재처리를 하기 위해서 **@Retryable**을 활용해 재시도를 할 수도 있다. 하지만 **비정상 종료가 되는 경우에는 처리가 어렵**기 때문에 최종적 일관성을 보장하는 `아웃박스 패턴`이나 `메세지 큐`를 도입하여 **데이터의 신뢰성을 보장**해야 한다.
### 왜 EventListener를 활용하여 구현했나요?
**D**I를 통해 구현하면 **알림 서비스의 장애가 전파**되기 때문입니다. 그래서 도메인 로직이 정상적으로 수행되었음에도 알림 서비스에서 **오류가 발생하면 롤백**이 되기 때문에 **두 도메인 간의 결합을 느슨하게 만들었습니다**.

### 스프링 이벤트의 동작 원리를 설명해주세요.
1. publisher로 이벤트를 발행합니다.
2. **스프링 컨텍스트**에 등록된 **모든 리스너에게 브로드 캐스팅**됩니다.
3. **리스너는 특정 이벤트에 반응**합니다. 이벤트가 수신되면 **로직을 수행**합니다.

### authorization code가 탈취되면?
**secret key**도 서버에서 관리하기 때문에 탈취자가 code를 탈취하더라도 token을 요청할 수 없기 때문에 보안적으로 안전하다고 생각합니다.
state를 활용해서 요청이 변조되었는지 확인할 수 있을 것 같다.


[oidc 방식](https://syoun602.tistory.com/18)


### oauth 프로토콜이란?
- **사용자의 로그인 정보(자격 증명)를 공유**하지 않고도 **제3자** 서비스가 **사용자 정보를 안전하게 접근**할 수 있도록 하는 **인가 프로토콜**입니다.
- 구글이나 카카오, 네이버 등이 Oauth 프로토콜을 활용해서 자사의 로그인 정보를 활용해 다른 웹사이트에 로그인할 수 있도록 제공하고 있습니다.

### 테스트 커버리지와의 안정성의 상관관계
테스트 커버리지를 높인다고 **모든 예외 상황을 컨트롤 할 수는 없지만**, **코드의 어디에 테스트되고 있는지를 나타내는 지표** 로 활용될 수 있다고 생각합니다. 예를 들어 라인 별로 테스트를 할 수 있습니다. 그래서 만약 테스트 커버리지가 낮다면 특정 코드가 테스트되지 않은 상태여서 테스트 작성을 유도할 수 있다고 생각합니다. 그래서 전체적인 프로젝트 전체의 안정성 향상을 준다고 생각합니다.


### 테스트 왜 해야 한다고 생각해요?
- **유지보수성을 높인다**고 생각합니다.
- **리팩토링**을 할 때도 작성해둔 테스트 코드를 통해서 이전과 같은 결과가 발생하는지 빠르게 확인할 수 있기 때문입니다.
- 또한 **해당 기능을 잘 모르는 개발자한테 지침표**가 되기도 한다고 생각합니다. 예를 들어, 도메인에 대해서 아무것도 모르는 개발자가 어떤 시나리오에 의해 해당 메서드가 실행되는지 알 수 있기 대문입니다.

### 테스트에서 중요한게 뭐에요?
- **빠르고**  - ci/cd 시 환경에서의 실행 속도 때문에
- **반복 가능**하며 - 동일한 환경에서 언제나 같은 값이 나와야 함
- **다른 테스트와 격리**되어야 한다고 생각합니다. - 테스트 간 상호 의존성이 발생하면 테스트 신뢰성 떨어짐


### Webflux를 아시나요?
사용해본 적은 없지만 **비동기 및 논블로킹을 지원**하는 **리액티브 프로그래밍 프로젝트**로 알고 있습니다.  **이벤트 기반 아키텍처를 사용**하고 **비동기를 기반**으로 동작하기 때문에 **동기적 프로그래밍보다 성능이 좋은 편입니다.**  Spring MVC는 **블로킹이 기반**이기 때문에 대규모 트래픽을 지원하는 환경에서 많이 사용하는 것으로 알고 있습니다. 

(추가 공부 필요) Spring MVC는 요청당 하나의 스레드를 사용함, Webflux는 적은 스레드로도 더 많은 요청을 처리할 수 있습니다.


### @Scheduled의 동작방식
- 별도의 쓰레드 풀을 사용하지 않으면 디폴트로 단일 스레드로 동작함.
- 빈 후처리기에서 @Schedule 어노테이션이 붙은 메서드 작업을 Map에 등록합니다.
- 그리고 큐에 작업을 등록하고 스케줄러를 실행한다.


**고려해야 할 점**
- 스케줄러의 스케줄링 방식에 의해 중복 실행될 수 있기 때문에 fixedDelay를 사용하거나 락을 사용해서 중복 호출을 제어해야 할 수도 있다.
- 실패 처리 -> 스케줄러에서 실패가 발생하면 어떡할 것인지 고려해야 한다.
- 예약 작업이 종료될 때 갑자기 종료되지 않도록 해야 한다.
- 풀 크기 구성 고려
	- 풀 크기가 너무 작으면 큐 지연 발생
	- 너무 큰 풀은 리소스 경합이나, 컨텍스트 전환 오버헤드가 발생

### readtimeout 짧으면 왜 안 돼?
- TCP 커넥션을 자주 맺게 되어 SSE의 장점이 상쇄되기 때문입니다. 이렇게 되면 유저 한 명당 지속적으로 polling을 하는 것이나 다름 없기 때문입니다. 그리고 재연결되는 과정에서 이벤트가 누락될 수도 있어서 로그인한 유저는 오래 유지하고 로그인 하지 않은 유저는 빠르게 정리할 수 있는 heartbeat 방식을 도입했습니다.
### 소켓 오래 유지하면 안 돼?
- 소켓이 오래 유지되면 불필요한 메모리를 사용하기 때문입니다. 네트워크를 유지하기 위해 송수신 버퍼를 메모리에 할당하고 또한 TCP 연결을 관리하기 위해 커넥션 테이블을 커널에서 관리하는 것으로 알고 있습니다. 그래서 readtimeout을 늘려 이미 끊어진 연결을 유지하는 경우나, 많은 트래픽이 몰렸을 때 메모리의 사용률이 올라가기 때문에 

https://medium.com/hprog99/mastering-job-scheduling-in-spring-boot-from-basics-to-best-practices-74ab938d80fa
https://medium.com/@AlexanderObregon/the-mechanics-behind-task-scheduling-in-spring-boot-f3b4ae3c0db8