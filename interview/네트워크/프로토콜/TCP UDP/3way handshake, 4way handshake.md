## TCP의 3-way-handshake와 4-way-handshake를 비교 설명해주세요.

- 3-way-handshake는 TCP의 **접속 수립 과정**이고 4-way-hanshake는 **접속 해제 과정**입니다.
- TCP 프로토콜을 통해 데이터를 전송하기 전에 상대 컴퓨터와 사전에 세션을 수립하는 과정을 의미합니다.
- **SYN, ACK 플래그**를 활용하여 접속을 수립합니다.

⠀**3-way-handshake**

- 클라이언트가 서버로 **SYN 플래그**를 전송합니다.
- 서버가 SYN 플래그를 **전달 받고, 받았다는 신호로 ACK, SYN**를 전송합니다.
- 클라이언트가 신호를 전달 받았다는 표시로 **ACK 신호를 서버**로 보냅니다. 이때, 전송할 데이터가 있으면 이 단계에서 데이터를 전송할 수 있습니다.

```
1. 클라이언트  -------- [SYN] -------->  서버   (SYN_SENT)
2. 클라이언트  <---- [SYN + ACK] ------  서버   (SYN_RECEIVED)
3. 클라이언트  -------- [ACK] -------->  서버   (ESTABLISHED)
```

⠀**4-way-handshake**

- `FIN` 플래그를 추가로 활용하여 접속을 해제합니다.
- 연결의 한쪽에서 `FIN` 플래그가 전송됩니다.
- `FIN` 플래그를 받을 쪽에서 해제에 대한 확인으로 `ACK` 플래그를 전송합니다.
- 이후 서버가 모든 데이터를 전송 완료하면 `FIN` 플래그를 전송합니다.
- `FIN` 플래그를 수신한 클라이언트가 최종 확인으로 `ACK` 플래그를 전송합니다. 이 단계에서 **서버는 연결을 종료**하고, 클라이언트는 `TIME_WAIT` 상태로 **지연 패킷이 있는지 확인**합니다.
- 시간이 지나면 **클라이언트도 종료**합니다.

```
1. 클라이언트  -------- [FIN] -------->  서버  (FIN_WAIT_1)
2. 클라이언트  <------- [ACK] --------  서버   (FIN_WAIT_2)
3. 클라이언트  <------- [FIN] --------  서버   (LAST_ACK)
4. 클라이언트  -------- [ACK] -------->  서버  (TIME_WAIT)
```

## TIME_WAIT란?
**지연 패킷**을 기다리기 위한 상태로 **데이터 손실을 방지할 수 있는 상태**입니다.

## 왜 네번의 단계가 필요한가요? (2+3 안 되는 이유?)

- 클라이언트가 데이터를 전부 전송했다고 해도 **서버가 아직 보낼 데이터가 남아있을 수 있기 때문**입니다. 그래서 일단 FIN에 대한 응답으로 ACK만 보내고, 이후 자신의 전송이 완료되었을 때 FIN 플래그를 전송합니다.

## 2-way는 안 되나요?

- 2-way는 신뢰할 수 없습니다. 여기서 **신뢰**란 신뢰된 요청과 응답이 가능해야한다는 의미입니다. 만약 2-way를 하는 경우, **서버가 데이터를 전송**하는데 신뢰할 수 없기 때문에 **신뢰할 수 없는 통신**이 됩니다.

## SYN Flooding이 무엇인가요?

- SYN Flooding은 3-way-handshake 과정에서 클라이언트가 SYN 플래그만 계속 보내고 **ACK 패킷을 보내지 않는 공격 방법**입니다. 서버는 클라이언트로부터 SYN 패킷을 받으면 연결을 받아들이기 위해 메모리 공간을 확보합니다. 이때 연결 수립이 정상적으로 되지 않아 메모리 공간을 소진하게 만드는 방법입니다.
- SYN Cookie를 활용하는 방법이 있습니다. 중간에 방화벽을 두고 SYN 요청이 오면 SYN Cookie를 함께 보냅니다. 일정 시간 동안 SYN Cookie에 대한 정상 응답이 오지 않으면 방화벽에서 차단하는 방식입니다.

https://sata.kr/entry/DOSDDOS-SYN-Flooding-공격에-대해서-알아보자


