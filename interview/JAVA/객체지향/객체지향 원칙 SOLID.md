## SOLID란?
- **[응집도를 높이고 결합도를 낮추기](응집도와%20결합도.md 결합도>)** 위해 고안된 **객체지향 원칙**이다.

## SOLID의 원칙
- **SRP**(Single Responsibility Principle) : 단일 책임 원칙
- **OCP**(Open-Closed Principle) : 개방 폐쇄 원칙
- **LSP**(Liskov Substitution Principle) : 리스코프 치환 원칙
- **ISP**(Interface Segregation Principle) : 인터페이스 분리 원칙
- **DIP**(Dependency Inversion Principle) : 의존 역전 원칙

## SRP - 단일 책임 원칙
- 클래스는 단 **하나의 책임**을 가져야 한다. 즉, 변경의 원인은 단 하나여야 한다는 원칙이다.
- 모델링 과정을 담당하는 **추상화**와 관련이 깊다.
#### 기준
- 클래스는 단일 책임
- 메소드는 단일 기능

#### 함수 예시
- add, print, add+print 함수

### 왜 단일 책임 원칙을 지켜야 할까?
- 요구사항을 반영했을 때 **관련 코드들이 같이 수정될 가능성이 높아진다**.
- 재사용이 어려워진다.

## OCP - 개방 폐쇄 원칙
> “자신의 확장에는 열려 있고, 주변의 변화에 대해서는 닫혀 있어야 한다.”
- 기능을 변경, 확장할 때 **그 기능을 사용하는 코드(클라이언트)는 수정하지 않아야 한다**.

**예시**
- JDBC
- 스프링 프레임워크
### OCP 구현 방법
- 인터페이스 혹은 상속

### OCP 위반을 확인하는 방법
- instanceof 사용
- 과도한 if-else

### 장점
- 기존 모듈을 변경하지 않고 확장할 수 있는 방법을 제공하여 **유연성과 확장성**을 높인다.

OCP는 변경이 예상되는 것을 추상화해서 변경의 유연함을 얻도록 해준다.


## LSP - 리스코프 치환 원칙
> “서브 타입은 언제나 기반 타입으로 교체할 수 있어야 한다.”

즉, 하위 클래스의 인스턴스는 상위형 객체 참조 변수에 대입해 상위 클래스의 인스턴스 역할을 하는데 문제가 없어야 한다.

## ISP - 인터페이스 분리 원칙
> “클라이언트는 자신이 사용하지 않는 메서드에 의존 관계를 맺으면 안 된다.”

## DIP - 의존 역전 원칙
> “추상화된 것은 구체적인 것에 의존하면 안 된다. 구체적인 것이 추상화된 것에 의존해야 한다.” “자주 변경되는 구체 클래스에 의존하지 마라.”

- 추상화된 인터페이스나 상위 클래스를 두어 변하기 쉬운 것의 **변화에 영향받지 않게 하는 것**이 목적이다.
- 지키지 않으면 **클라이언트**가 구현체의존성이 강해져 테스트가 어려워지고 유지보수가 어렵다.

### 장점
- 의존성의 방향을 조절하여 유연성을 증가시킨다.

